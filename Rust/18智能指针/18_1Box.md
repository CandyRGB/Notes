## `Box<T>`
`Box<T>`最简单的智能指针：
- 允许在堆上存放数据
- 在栈上是指向堆上数据的指针

定义大致如下：
```rust
struct Box<T> {
    // pointer字段指向堆上分配的内存，存储T类型的值
    pointer: *mut T,
}
```
这里的`*`用于表示**裸指针**（raw pointer）。
**裸指针**是一种直接或间接指向某块内存的指针，它不进行任何所有权检查，也不自动管理内存的生命周期。使用`*`定义的裸指针有两种形式：
- `*const T`：一个不可变的裸指针，指向T类型的数据。
- `*mut T`：一个可变的裸指针，指向T类型的数据，允许修改指向的数据。

### 常用场景
- 在编译时，有一个未知大小的类型。但使用该类型时，上下文中需要知道它的确切大小。
- 当你有大量数据，想移交所有权，但希望在操作时数据不被复制。
- 使用某个值时，只关心它的类型是否实现了特定 trait ，而不关心其具体类型。

### 使用`Box<T>`在堆上储存数据
如果`let hp = 100`，那么这个`i32`类型的变量就会被存放在栈上。下面我们使用`Box`在堆上储存一个`i32`：
```rust
let hp = Box::new(100);
dbg!(hp);
```
这里定义了一个值是指向一个被分配在堆上的`100`的`Box`。

### 使用 Box 赋能递归类型
Rust 需要在编译时知道类型占用多少空间，**递归类型**（recursive type）的值可以拥有另一个同类型的值作为其自身的一部分，它的大小是不确定的。比如链表这种数据结构。
由于Rust的引用无法取null，因此可以通过`Option`这个枚举类型来表示这个结点是否是链表结尾，我们可以像 *C语言* 那样定义一个链表结点：
```rust
struct Node<'a> {
    data: i32,
    next: Option<&'a Node<'a>>
}
```
进一步，既然必须使用枚举类型，而枚举类型可以保存数据，我们便可以让枚举中的一个变体为保存元组，另一个表示链表结尾，从而不使用结构体：
```rust
enum List<'a> {
    Cons(i32, &'a List<'a>),
    Nil,
}
```
这样做还是有问题的，因为链表结点现在存放在栈上，而链表的特性是随机存储，我们需要在堆上存储数据：
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```
这样智能指针`Box`就会让它指向的数据存放到堆上，实现了链表的随机存储。
下面我们使用它创建一个链表实例：
```rust
fn main() {
    let list = Cons(1, Box::new(
        Cons(2, Box::new(
            Cons(3, Box::new(Nil))))));
}
```