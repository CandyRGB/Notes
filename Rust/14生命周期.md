# <center>生命周期</center>
Rust 中的每一个引用都有其**生命周期**（lifetime），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，但当引用的生命周期可能以不同方式互相关联时，就需要手动标注生命周期。

## 生命周期可以避免悬垂引用
**悬垂引用**：代码中存在对已经释放（或不再有效）的内存区域的引用。
当一个指针指向的内存被释放后，如果该指针没有被设置为 NULL 或者没有被适当地管理，它就变成了一个**悬垂指针**。如果程序继续使用这个指针，就会尝试访问一个不再分配给它的内存区域，这就是**悬垂引用**。
生命周期的主要目标是避免悬垂引用，分析下例中各个变量的生命周期：
```rust
// 拒绝编译
fn main() {
    let r;             //-------+--'a
    {                  //       |
        let x = 5;     //-+--'b |
        r = &x;        // |     |
    }                  //-+     |
    println!("r: {r}");//       |
}                      //-------+
```
在注释中标明了生命周期，x的生命周期结束后，r还保持着对x的引用，rust编译器的**借用检查器**就会识别到问题拒绝编译。

## 生命周期标注语法
1. **参数名称**：必须以撇号（`'`）开头，其名称通常全是小写，类似于泛型其名称非常短。大多数人使用`'a`作为第一个生命周期注解。
2. **标注位置**：在`&`引用之后，`mut`之前

## 函数中的泛型生命周期
```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}

// 拒绝编译
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
上例中我们想要获取较长的字符串，但`longest()`函数被拒绝编译。因为函数并不知道到底是返回函数签名里的x还是y，借用检查器不知道返回值的生命周期是与x还是与y的生命周期相关。为了修复这个错误，我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。
为了在函数签名中使用生命周期标注，需要在函数名和参数列表间的尖括号中声明泛型生命周期（lifetime）参数，就像泛型类型（type）参数一样。
```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
经过标注生命周期后，借用检查器知道了`x`、`y`和返回的引用的生命周期相同，程序编译通过。
在上例中，传入的参数确实是同一个生命周期，接下来来看看传入参数不是同一生命周期的情况：
```rust
// 拒绝编译
fn main() {
    let string1 = String::from("long string is long");       //-------+--'a
    let result;                                              //-------+--'a
    {                                                        //       |
        let string2 = String::from("xyz");                   //-+--'b |
        result = longest(string1.as_str(), string2.as_str());// |     |
    }                                                        //-+     |
    println!("The longest string is {result}");              //       |
}                                                            //-------+
```
我们通过生命周期参数告诉 Rust 的是：`longest`函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。由于`'b`短于`'a`，返回的引用的生命周期就是`'b`，但是`result`在生命周期`'b`之后作为参数使用了，所以程序被拒绝编译。

## 结构体定义中的生命周期标注
定义包含引用的结构体，需要为结构体定义中的每一个引用添加生命周期标注。
```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

## 生命周期省略
### 输入/输出生命周期
- **输入生命周期**：函数或方法的参数的生命周期。
- **输出生命周期**：返回值的生命周期。

### 规则
当应用三条规则之后，编译器能推断出全部的输入/输出生命周期，那么生命周期可以省略。
1. 编译器为每一个引用参数都分配一个生命周期参数。
2. 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数。
3. 如果方法有多个输入生命周期参数并且其中一个参数是`&self`或`&mut self`，那么所有输出生命周期参数被赋予`self`的生命周期。

## 静态生命周期
`'static`是一个特殊的生命周期，能够存活于整个程序期间。所有的字符串字面值都拥有`'static`生命周期。